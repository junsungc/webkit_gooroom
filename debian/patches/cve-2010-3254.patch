Description: fix cve-2010-3254
Author: Michael Gilbert <michael.s.gilbert@gmail.com>
Origin: http://trac.webkit.org/changeset/65135
Index: webkit/WebCore/websockets/WebSocketChannel.cpp
===================================================================
--- webkit.orig/WebCore/websockets/WebSocketChannel.cpp	2010-11-14 18:47:14.000000000 -0500
+++ webkit/WebCore/websockets/WebSocketChannel.cpp	2010-11-14 18:53:58.000000000 -0500
@@ -195,25 +195,50 @@
     while (p < end) {
         unsigned char frameByte = static_cast<unsigned char>(*p++);
         if ((frameByte & 0x80) == 0x80) {
-            int length = 0;
+            size_t length = 0;
+            bool errorFrame = false;
             while (p < end) {
-                if (length > std::numeric_limits<int>::max() / 128) {
-                    LOG(Network, "frame length overflow %d", length);
-                    m_client->didReceiveMessageError();
-                    if (!m_client)
-                        return;
-                    handle->close();
-                    return;
+                if (length > std::numeric_limits<size_t>::max() / 128) {
+                    LOG(Network, "frame length overflow %lu", length);
+                    errorFrame = true;
+                    break;
+                }
+                size_t newLength = length * 128;
+                unsigned char msgByte = static_cast<unsigned char>(*p);
+                unsigned int lengthMsgByte = msgByte & 0x7f;
+                if (newLength > std::numeric_limits<size_t>::max() - lengthMsgByte) {
+                    LOG(Network, "frame length overflow %lu+%u", newLength, lengthMsgByte);
+                    errorFrame = true;
+                    break;
+                }
+                newLength += lengthMsgByte;
+                if (newLength < length) { // sanity check
+                    LOG(Network, "frame length integer wrap %lu->%lu", length, newLength);
+                    errorFrame = true;
+                    break;
                 }
-                char msgByte = *p;
-                length = length * 128 + (msgByte & 0x7f);
+                length = newLength;
                 ++p;
                 if (!(msgByte & 0x80))
                     break;
             }
+            if (p + length < p) {
+                LOG(Network, "frame buffer pointer wrap %p+%lu->%p", p, length, p + length);
+                errorFrame = true;
+            }
+            if (errorFrame) {
+                m_client->didReceiveMessageError();
+                if (!m_client)
+                    return false;
+                if (!m_closed)
+                    m_handle->close();
+                return false;
+            }
+            ASSERT(p + length >= p);
             if (p + length < end) {
                 p += length;
                 nextFrame = p;
+                ASSERT(nextFrame > m_buffer);
                 m_client->didReceiveMessageError();
                 if (!m_client)
                     return;
@@ -253,23 +278,28 @@
 {
 }
 
-bool WebSocketChannel::appendToBuffer(const char* data, int len)
+bool WebSocketChannel::appendToBuffer(const char* data, size_t len)
 {
+    size_t newBufferSize = m_bufferSize + len;
+    if (newBufferSize < m_bufferSize) {
+        LOG(Network, "WebSocket buffer overflow (%lu+%lu)", m_bufferSize, len);
+        return false;
+    }
     char* newBuffer = 0;
-    if (tryFastMalloc(m_bufferSize + len).getValue(newBuffer)) {
+    if (tryFastMalloc(newBufferSize).getValue(newBuffer)) {
         if (m_buffer)
             memcpy(newBuffer, m_buffer, m_bufferSize);
         memcpy(newBuffer + m_bufferSize, data, len);
         fastFree(m_buffer);
         m_buffer = newBuffer;
-        m_bufferSize += len;
+        m_bufferSize = newBufferSize;
         return true;
     }
-    m_context->addMessage(ConsoleDestination, JSMessageSource, LogMessageType, ErrorMessageLevel, String::format("WebSocket frame (at %d bytes) is too long.", m_bufferSize + len), 0, m_handshake.clientOrigin());
+    m_context->addMessage(ConsoleDestination, JSMessageSource, LogMessageType, ErrorMessageLevel, String::format("WebSocket frame (at %lu bytes) is too long.", newBufferSize), 0, m_handshake.clientOrigin());
     return false;
 }
 
-void WebSocketChannel::skipBuffer(int len)
+void WebSocketChannel::skipBuffer(size_t len)
 {
     ASSERT(len <= m_bufferSize);
     m_bufferSize -= len;
Index: webkit/WebCore/websockets/WebSocketChannel.h
===================================================================
--- webkit.orig/WebCore/websockets/WebSocketChannel.h	2010-11-14 18:47:14.000000000 -0500
+++ webkit/WebCore/websockets/WebSocketChannel.h	2010-11-14 18:51:36.000000000 -0500
@@ -74,15 +74,15 @@
     private:
         WebSocketChannel(ScriptExecutionContext*, WebSocketChannelClient*, const KURL&, const String& protocol);
 
-        bool appendToBuffer(const char* data, int len);
-        void skipBuffer(int len);
+        bool appendToBuffer(const char* data, size_t len);
+        void skipBuffer(size_t len);
 
         ScriptExecutionContext* m_context;
         WebSocketChannelClient* m_client;
         WebSocketHandshake m_handshake;
         RefPtr<SocketStreamHandle> m_handle;
         char* m_buffer;
-        int m_bufferSize;
+        size_t m_bufferSize;
     };
 
 } // namespace WebCore
